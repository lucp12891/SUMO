#all_indices = c(shared, omic_one_unique, omic_two_unique)
factor_xtics <- list(
shared = shared,
omic_one_unique = omic_one_unique,
omic_two_unique = omic_two_unique
)
### * * * * * * * * * * * * * * * * * * * * ** * * * * First OMIC data * * * * * * * * * * * * * * * * * * * * * * * * * *#
# FeaturesD signal start_and_end
assigned_indices_features = feature_selection_one(n_features_one = n_features_one, num.factor = "multiple", no_factor = n_factors)
# Generate random beta values based on the max_factors
list_betas <- list()
# Create only one vector in list_betas using the random index
for (i in seq_along(assigned_indices_features)) {
list_betas[[i]] <- rnorm(n_features_one, 0, 0.05)
}
# Loop through the ordered indices in list_omic_one_factors
for (i in seq_along(assigned_indices_features)) {
indices_ns <- assigned_indices_features[[i]]  # Get the corresponding indices from assigned_indices_features
if (length(indices_ns) > 0) {
# Initialize list_betas[[i]] if it's not already
if (is.null(list_betas[[i]])) {
list_betas[[i]] <- numeric(max(indices_ns))
}
# Assign values to the appropriate indices in list_betas
list_betas[[i]][indices_ns] <- rnorm(length(indices_ns), mean = 0, sd = signal.features.one[2])
}
}
# Renaming list_betas to desired factor number
list_omic_factors <- seq_along(1:n_factors)
for (i in seq_along(list_omic_factors)) {
names(list_betas)[i] <- paste0("beta", list_omic_factors[[i]])#list_omic_one_factors[[i]]
}
pattern_alpha <-"^alpha\\d+"
matches_alpha <- grepl(pattern_alpha, names(list_alphas), perl = TRUE)
n_alpha = length(matches_alpha[matches_alpha == TRUE])
pattern_beta <- "^beta\\d+"
matches_beta <- grepl(pattern_beta, names(list_betas), perl = TRUE)
n_beta = length(matches_beta[matches_beta == TRUE])
# Initialize the data list to store the results
data_list_i <- list()
# Sort the list by names in ascending order
list_betas <- list_betas[order(names(list_betas))]
list_alphas <- list_alphas[order(names(list_alphas))]
# Extract the last numeric values from the names of the vectors
alphas_names <- as.numeric(gsub("[^0-9]", "", names(list_alphas)))
betas_names <- as.numeric(gsub("[^0-9]", "", names(list_betas)))
# Find common numbers between the last values of the vector names
common_names <- intersect(alphas_names, betas_names)
# Filter the vectors in each list based on the common names
list_alphas <- list_alphas[paste0("alpha", common_names)]
list_betas <- list_betas[paste0("beta", common_names)]
# Loop through each alpha and beta combination
for (i in 1:min(length(list_alphas), length(list_betas))) {
data_i <- list_alphas[[i]] %*% t(list_betas[[i]][1:n_features_one])
data_list_i[[paste0("data.", i)]] <- data_i
}
# Combine the results into a single data variable
data.1 <- Reduce(`+`, data_list_i)
eps1 <- rnorm(n_samples * n_features_one, 0, sigmas) # noise
omic.one <- list()
omic.one[[length(omic.one) + 1]] <- matrix(data.1, n_samples, n_features_one) + matrix(eps1, n_samples, n_features_one) # signal + noise
colnames(omic.one[[length(omic.one)]]) <- paste0('omic1_feature_', seq_len(n_features_one))
rownames(omic.one[[length(omic.one)]]) <- paste0('sample_', seq_len(n_samples))
#dataset <- omic.one[[1]]
#image(c(1:dim(dataset)[1]), c(1:dim(dataset)[2]), dataset, ylab = "Features", xlab = "Samples")
### * * * * * * * * * * * * * * * * * * * * * * * Second OMIC data * * * * * * * * * * * * * * * * * * * * * *
# Noise in the first detasets
sigmas <- (signal.samples[1]*signal.features.two[1])/snr #sigmas_vector[2]
# Generate random gamma values based on the max_factors
list_gammas <- list_alphas
# Replace 'alpha' with 'gamma' in the names of list_gammas
names(list_gammas) <- gsub("alpha", "gamma", names(list_gammas))
# Extract the numeric parts from the names of list_gammas
numeric_part <- as.numeric(gsub("\\D", "", names(list_gammas)))
# Retain elements where the numeric part of the name matches values in list_omic_two_factors
list_gammas <- list_gammas[numeric_part %in% list_omic_factors]
# Features
assigned_indices_features_omic.two = feature_selection_two(n_features_two = n_features_two, num.factor = "multiple", no_factor = length(list_omic_factors))
(shuffled_assigned_indices_features_omic.two <- sample(assigned_indices_features_omic.two))
# Empty list
list_deltas <- list()
# Create only one vector in list_deltas using the random index
for (i in seq_along(shuffled_assigned_indices_features_omic.two)) {
list_deltas[[i]] <- rnorm(n_features_two, 0, 0.05)
}
for (i in seq_along(shuffled_assigned_indices_features_omic.two)) {
indices_ns <- shuffled_assigned_indices_features_omic.two[[i]]  # Get the corresponding indices from assigned_indices_features_omic.two
# Remove NA values from indices_ns
indices_ns <- indices_ns[!is.na(indices_ns)]
if (length(indices_ns) > 0) {
# Initialize list_deltas[[i]] if it's not already
if (is.null(list_deltas[[i]])) {
list_deltas[[i]] <- numeric(max(indices_ns, na.rm = TRUE))  # Use na.rm = TRUE to handle potential NA
}
# Ensure indices are within the range of list_deltas[[i]]
if (max(indices_ns) > length(list_deltas[[i]])) {
length(list_deltas[[i]]) <- max(indices_ns)
}
# Assign values to the appropriate indices in list_deltas
list_deltas[[i]][indices_ns] <- rnorm(length(indices_ns), mean = (signal.features.two[1] + 0.4 * i), sd = signal.features.two[2])
}
}
# Renaming list_deltas to desired factor number
list_omic_factors <- seq_along(1:n_factors)
for (i in seq_along(list_omic_factors)) {
names(list_deltas)[i] <- paste0("delta", list_omic_factors[[i]])#list_omic_one_factors[[i]]
}
pattern_gamma <-"^gamma\\d+"
matches_gamma <- grepl(pattern_gamma, names(list_gammas), perl = TRUE)
n_gamma = length(matches_alpha[matches_gamma == TRUE])
pattern_delta <- "^delta\\d+"
matches_delta <- grepl(pattern_delta, names(list_deltas), perl = TRUE)
n_delta = length(matches_delta[matches_delta == TRUE])
# Initialize the data list to store the results
data_list_j <- list()
# Sort the list by names in ascending order
list_gammas <- list_gammas[order(names(list_gammas))]
list_deltas <- list_deltas[order(names(list_deltas))]
# Extract the last numeric values from the names of the vectors
gammas_names <- as.numeric(gsub("[^0-9]", "", names(list_gammas)))
deltas_names <- as.numeric(gsub("[^0-9]", "", names(list_deltas)))
# Find common numbers between the last values of the vector names
common_names <- intersect(gammas_names, deltas_names)
# Filter the vectors in each list based on the common names
list_gammas <- list_gammas[paste0("gamma", common_names)]
list_deltas <- list_deltas[paste0("delta", common_names)]
# Loop through each alpha and beta combination
for (j in 1:min(length(list_gammas), length(list_deltas))) {
data_j <- list_gammas[[j]] %*% t(list_deltas[[j]][1:n_features_two])
data_list_j[[paste0("data.", j)]] <- data_j
}
# Combine the results into a single data variable
data.2 <- Reduce(`+`, data_list_j)
eps2 <- rnorm(n_samples * n_features_two, 0, sigmas)
omic.two[[length(omic.two) + 1]] <- matrix(data.2, n_samples, n_features_two) + matrix(eps2, n_samples, n_features_two) # signal + noise
colnames(omic.two[[length(omic.two)]]) <- paste0('omic2_feature_', seq_len(n_features_two))
rownames(omic.two[[length(omic.two)]]) <- paste0('sample_', seq_len(n_samples))
#dataset <- data.2#dataset <- omic.two[[1]]
#image(c(1:dim(dataset)[1]), c(1:dim(dataset)[2]), dataset, ylab = "Features", xlab = "Samples")
simulated_datasets <- list(object.one = omic.one, object.two = omic.two)
concatenated_datasets <- list()
for (i in 1:length(simulated_datasets$object.two)) {
concatenated_data <- cbind(simulated_datasets$object.two[[i]],simulated_datasets$object.one[[i]])
concatenated_datasets[[i]] <- concatenated_data
}
signal_annotation = list(samples = assigned_indices_samples, omic.one = assigned_indices_features, omic.two = assigned_indices_features_omic.two)
sim_output <- list(concatenated_datasets=concatenated_datasets, omic.one=omic.one, omic.two=omic.two, signal_annotation = signal_annotation, factor_xtics=factor_xtics, list_alphas=list_alphas, list_gammas=list_gammas, list_betas=list_betas, list_deltas=list_deltas)#simulated_datasets=simulated_datasets)
#sim_output <- list(concatenated_datasets=concatenated_datasets, omic.one=omic.one, omic.two=omic.two, assigned_indices_samples = assigned_indices_samples, assigned_indices_features = assigned_indices_features, assigned_indices_features_omic.two=assigned_indices_features_omic.two, factor_xtics=factor_xtics, list_alphas=list_alphas, list_gammas=list_gammas, list_betas=list_betas, list_deltas=list_deltas)#simulated_datasets=simulated_datasets)
return(sim_output)
}else if(advanced_dist == 'exclusive'){
# Code to execute if advanced_dist is "exclusive"
# features
n_features_one <- vector_features[1]
n_features_two <- vector_features[2]
# Noise in the first detasets
sigmas <- (signal.samples[1]*signal.features.one[1])/snr #sigmas_vector[1]
#num_factor = num_factors
omic.one <- list()
omic.two <- list()
assigned_indices_samples <- divide_samples(n_samples = n_samples, num=n_factors, min_size=10)
#print(assigned_indices_samples)
# sample indices
# Check the max number of factors in assigned_indices_samples
max_factors <- length(assigned_indices_samples)# Same as n_factors
# Generate random alpha values based on the max_factors
list_alphas <- list()
for (i in 1:max_factors) {
list_alphas[[paste0("alpha", i)]] <- rnorm(n_samples, 0, 0.05)
}
# Assign corresponding values to alpha variables based on assigned_indices_samples
for (i in seq_along(assigned_indices_samples)) {
indices <- assigned_indices_samples[[i]]
list_alphas[[i]][indices] <- rnorm(length(indices), (signal.samples[1] + 0.5*i), signal.samples[2])  # Adjust values dynamically
}
list_gammas <- list_alphas
# Add the separated list of the indices selected for omics of multiple features
# Initial vector
vector <- c(1:max_factors)
# Specify the number of elements to sample for the shared vector
num_shared <- 0#ceiling(runif(1, min = 1, max = length(vector) - 1))
# Select the 'shared' elements
if (num_shared > 0) {
shared <- sample(vector, num_shared)
# Remove the selected shared elements from the vector
remain_vector <- vector[!vector %in% shared]
}else{
shared <- 0
remain_vector <- vector
}
# Shuffle the remaining vector
if(length(remain_vector == 1)){
shuffled_remain = remain_vector
} else{
shuffled_remain <- sample(remain_vector)
}
# Split the shuffled elements equally or nearly equally between omic_one_unique and omic_two_unique
num_elements <- length(shuffled_remain)
split_point <- sample(1:(num_elements-1), 1) # Randomly select a split point
omic_one_unique <- shuffled_remain[1:split_point] # First part goes to omic_one_unique
omic_two_unique <- shuffled_remain[!shuffled_remain %in% omic_one_unique] # Second part goes to omic_two_unique
# Print the results
list(
shared = shared,
omic_one_unique = omic_one_unique,
omic_two_unique = omic_two_unique
)
# End of indices assignment
# Assignment of factors
list_omic_one_factors = omic_one_unique
list_omic_two_factors = omic_two_unique
#all_indices = c(shared, omic_one_unique, omic_two_unique)
factor_xtics <- list(
shared = shared,
omic_one_unique = omic_one_unique,
omic_two_unique = omic_two_unique
)
### * * * * * * * * * * * * * * * * * * * * ** * * * * First OMIC data * * * * * * * * * * * * * * * * * * * * * * * * * *#
# FeaturesD signal start_and_end
assigned_indices_features = feature_selection_one(n_features_one = n_features_one, num.factor = "multiple", no_factor = length(list_omic_one_factors))
# Generate random beta values based on the max_factors
list_betas <- list()
# Shuffle the list
(shuffled_assigned_indices_features <- assigned_indices_features)# sample(assigned_indices_features)) # Do not reshuffle first
# Create only one vector in list_betas using the random index
for (i in seq_along(assigned_indices_features)) {
list_betas[[i]] <- rnorm(n_features_one, 0, 0.05)
}
# Loop through the ordered indices in list_omic_one_factors
for (i in seq_along(assigned_indices_features)) {
indices_ns <- assigned_indices_features[[i]]  # Get the corresponding indices from assigned_indices_features
if (length(indices_ns) > 0) {
# Initialize list_betas[[i]] if it's not already
if (is.null(list_betas[[i]])) {
list_betas[[i]] <- numeric(max(indices_ns))
}
# Assign values to the appropriate indices in list_betas
list_betas[[i]][indices_ns] <- rnorm(length(indices_ns), mean = (signal.features.one[1] + 0.4 * i), sd = signal.features.one[2])
}
}
# Renaming list_betas to desired factor number
for (i in seq_along(list_omic_one_factors)) {
names(list_betas)[i] <- paste0("beta", list_omic_one_factors[[i]])#list_omic_one_factors[[i]]
}
pattern_alpha <-"^alpha\\d+"
matches_alpha <- grepl(pattern_alpha, names(list_alphas), perl = TRUE)
n_alpha = length(matches_alpha[matches_alpha == TRUE])
pattern_beta <- "^beta\\d+"
matches_beta <- grepl(pattern_beta, names(list_betas), perl = TRUE)
n_beta = length(matches_beta[matches_beta == TRUE])
# Initialize the data list to store the results
data_list_i <- list()
# Sort the list by names in ascending order
list_betas <- list_betas[order(names(list_betas))]
list_alphas <- list_alphas[order(names(list_alphas))]
# Extract the last numeric values from the names of the vectors
alphas_names <- as.numeric(gsub("[^0-9]", "", names(list_alphas)))
betas_names <- as.numeric(gsub("[^0-9]", "", names(list_betas)))
# Find common numbers between the last values of the vector names
common_names <- intersect(alphas_names, betas_names)
# Filter the vectors in each list based on the common names
list_alphas <- list_alphas[paste0("alpha", common_names)]
list_betas <- list_betas[paste0("beta", common_names)]
# Loop through each alpha and beta combination
for (i in 1:min(length(list_alphas), length(list_betas))) {
data_i <- list_alphas[[i]] %*% t(list_betas[[i]][1:n_features_one])
data_list_i[[paste0("data.", i)]] <- data_i
}
# Combine the results into a single data variable
data.1 <- Reduce(`+`, data_list_i)
eps1 <- rnorm(n_samples * n_features_one, 0, sigmas) # noise
omic.one <- list()
omic.one[[length(omic.one) + 1]] <- matrix(data.1, n_samples, n_features_one) + matrix(eps1, n_samples, n_features_one) # signal + noise
colnames(omic.one[[length(omic.one)]]) <- paste0('omic1_feature_', seq_len(n_features_one))
rownames(omic.one[[length(omic.one)]]) <- paste0('sample_', seq_len(n_samples))
#dataset <- omic.one[[1]]
#image(c(1:dim(dataset)[1]), c(1:dim(dataset)[2]), dataset, ylab = "Features", xlab = "Samples")
### * * * * * * * * * * * * * * * * * * * * ** * * * * Second OMIC data * * * * * * * * * * * * * * * * * * * * * * * * * *
# Noise in the first detasets
sigmas <- (signal.samples[1]*signal.features.two[1])/snr#sigmas_vector[2]
# Generate random gamma values based on the max_factors
#list_gammas <- list_alphas
# Replace 'alpha' with 'gamma' in the names of list_gammas
names(list_gammas) <- gsub("alpha", "gamma", names(list_gammas))
# Extract the numeric parts from the names of list_gammas
numeric_part <- as.numeric(gsub("\\D", "", names(list_gammas)))
# Retain elements where the numeric part of the name matches values in list_omic_two_factors
list_gammas <- list_gammas[numeric_part %in% list_omic_two_factors]
# Features
assigned_indices_features_omic.two = feature_selection_two(n_features_two = n_features_two, num.factor = "multiple", no_factor = length(list_omic_two_factors))
# Empty list
list_deltas <- list()
# Create only one vector in list_deltas using the random index
for (i in seq_along(assigned_indices_features_omic.two)) {
list_deltas[[i]] <- rnorm(n_features_two, 0, 0.05)
}
# # Loop through the ordered indices in list_omic_one_factors
for (i in seq_along(assigned_indices_features_omic.two)) {
indices_ns <- assigned_indices_features_omic.two[[i]]  # Get the corresponding indices from assigned_indices_features_omic.two
# Remove NA values from indices_ns
indices_ns <- indices_ns[!is.na(indices_ns)]
if (length(indices_ns) > 0) {
# Initialize list_deltas[[i]] if it's not already
if (is.null(list_deltas[[i]])) {
list_deltas[[i]] <- numeric(max(indices_ns, na.rm = TRUE))  # Use na.rm = TRUE to handle potential NA
}
# Ensure indices are within the range of list_deltas[[i]]
if (max(indices_ns) > length(list_deltas[[i]])) {
length(list_deltas[[i]]) <- max(indices_ns)
}
# Assign values to the appropriate indices in list_deltas
list_deltas[[i]][indices_ns] <- rnorm(length(indices_ns), mean = (signal.features.two[1] + 0.4 * i), sd = signal.features.two[2])
}
}
# Renaming list_deltas to desired factor number
for (i in seq_along(list_omic_two_factors)) {
names(list_deltas)[i] <- paste0("delta", list_omic_two_factors[[i]])#list_omic_one_factors[[i]]
}
pattern_gamma <-"^gamma\\d+"
matches_gamma <- grepl(pattern_gamma, names(list_gammas), perl = TRUE)
n_gamma = length(matches_alpha[matches_gamma == TRUE])
pattern_delta <- "^delta\\d+"
matches_delta <- grepl(pattern_delta, names(list_deltas), perl = TRUE)
n_delta = length(matches_delta[matches_delta == TRUE])
# Initialize the data list to store the results
data_list_j <- list()
# Sort the list by names in ascending order
list_gammas <- list_gammas[order(names(list_gammas))]
list_deltas <- list_deltas[order(names(list_deltas))]
# Extract the last numeric values from the names of the vectors
gammas_names <- as.numeric(gsub("[^0-9]", "", names(list_gammas)))
deltas_names <- as.numeric(gsub("[^0-9]", "", names(list_deltas)))
# Find common numbers between the last values of the vector names
common_names <- intersect(gammas_names, deltas_names)
# Filter the vectors in each list based on the common names
list_gammas <- list_gammas[paste0("gamma", common_names)]
list_deltas <- list_deltas[paste0("delta", common_names)]
# Loop through each alpha and beta combination
for (j in 1:min(length(list_gammas), length(list_deltas))) {
data_j <- list_gammas[[j]] %*% t(list_deltas[[j]][1:n_features_two])
data_list_j[[paste0("data.", j)]] <- data_j
}
# Combine the results into a single data variable
data.2 <- Reduce(`+`, data_list_j)
eps2 <- rnorm(n_samples * n_features_two, 0,sigmas)
omic.two[[length(omic.two) + 1]] <- matrix(data.2, n_samples, n_features_two) + matrix(eps2, n_samples, n_features_two) # signal + noise
colnames(omic.two[[length(omic.two)]]) <- paste0('omic2_feature_', seq_len(n_features_two))
rownames(omic.two[[length(omic.two)]]) <- paste0('sample_', seq_len(n_samples))
#dataset <- data.2#dataset <- omic.two[[1]]
#image(c(1:dim(dataset)[1]), c(1:dim(dataset)[2]), dataset, ylab = "Features", xlab = "Samples")
simulated_datasets <- list(object.one = omic.one, object.two = omic.two)
concatenated_datasets <- list()
for (i in 1:length(simulated_datasets$object.two)) {
concatenated_data <- cbind(simulated_datasets$object.two[[i]],simulated_datasets$object.one[[i]])
concatenated_datasets[[i]] <- concatenated_data
}
signal_annotation = list(samples = assigned_indices_samples, omic.one = assigned_indices_features, omic.two = assigned_indices_features_omic.two)
sim_output <- list(concatenated_datasets=concatenated_datasets, omic.one=omic.one, omic.two=omic.two, signal_annotation = signal_annotation, factor_xtics=factor_xtics, list_alphas=list_alphas, list_gammas=list_gammas, list_betas=list_betas, list_deltas=list_deltas)#simulated_datasets=simulated_datasets)
return(sim_output)
}
}else{
message <- "Error: If 'num.factor' must be provided with 'single' or 'multiple'"
print(message) # Display message immediately
return(message)
}
}
#'    show.legend = FALSE
#'    )
#'
#' plot_weights(
#'   sim_object = output_obj,
#'   factor_num = "all",
#'   data = 'omic.two',
#'   type = 'histogram'
#'   )
#' @export
plot_weights <- function(sim_object, factor_num = 1, data = 'omic.one', type = 'scatter', show.legend = TRUE) {
sim_data <- data.frame(sim_object$concatenated_datasets[[1]])
if (data == 'omic.one') {
features <- grep("^omic1_feature_", colnames(sim_data), value = TRUE)
factor_list <- sim_object$list_betas
} else if (data == 'omic.two') {
features <- grep("^omic2_feature_", colnames(sim_data), value = TRUE)
factor_list <- sim_object$list_deltas
} else {
stop("Invalid data section. Choose from 'omic.one' or 'omic.two'.")
}
factor_ids <- as.numeric(gsub("[^0-9]", "", names(factor_list)))
plot_list <- list()
if (factor_num == "all") {
for (i in factor_ids) {
factor <- factor_list[[paste0(ifelse(data == 'omic.one', 'beta', 'delta'), i)]]
df <- data.frame(features = features, factor = factor)
df$Index <- as.numeric(gsub(".*_(\\d+)$", "\\1", df$features))
df <- df[order(df$Index), ]
title <- paste("Data:", data, "| Factor:", i)
p <- if (type == 'scatter') {
build_scatter_plot(df, title, show.legend)
} else {
build_histogram_plot(df, title, show.legend)
}
plot_list[[i]] <- p
}
#return(gridExtra::grid.arrange(grobs = plot_list, ncol = length(plot_list)))
return(do.call(gridExtra::grid.arrange, c(plot_list, ncol = length(plot_list))))
} else if (factor_num %in% factor_ids) {
i <- factor_num
factor <- factor_list[[paste0(ifelse(data == 'omic.one', 'beta', 'delta'), i)]]
df <- data.frame(features = features, factor = factor)
df$Index <- as.numeric(gsub(".*_(\\d+)$", "\\1", df$features))
df <- df[order(df$Index), ]
title <- paste("Data:", data, "| Factor:", i)
if (type == 'scatter') {
return(build_scatter_plot(df, title, show.legend))
} else {
return(build_histogram_plot(df, title, show.legend))
}
} else {
stop("Invalid factor_num. Provide an integer matching available factor numbers or 'all'.")
}
}
#' Helper function to build scatter plot (internal use)
#' @param df Dataframe with features and weights
#' @param title Plot title
#' @param show.legend Logical to show legend
#' @keywords internal
build_scatter_plot <- function(df, title = "", show.legend = TRUE) {
p <- ggplot(df, aes(x = Index, y = factor, color = factor)) +
geom_point() +
labs(x = "Features", y = "Weights", color = "") +
scale_color_viridis_c() +
theme_bw() +
ggtitle(title) +
theme(plot.title = element_text(size = 10, hjust = 0.5))
if (!show.legend) p <- p + theme(legend.position = "none")
return(p)
}
#' Helper function to build histogram plot (internal use)
#' @param df Dataframe with features and weights
#' @param title Plot title
#' @param show.legend Logical to show legend
#' @keywords internal
build_histogram_plot <- function(df, title = "", show.legend = TRUE) {
p <- ggplot(df, aes(x = factor, fill = after_stat(x))) +
geom_histogram(bins = 100) +
labs(x = "Loadings", y = "Frequency", fill = "") +
scale_fill_viridis_c() +
theme_minimal() +
theme(
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
legend.position = if (show.legend) "right" else "none",
plot.title = element_text(hjust = 0.5)
) +
ggtitle(title)
return(p)
}
utils::globalVariables(c("Index", "x"))
output_obj <- OmixCraftHD(
vector_features = c(4000, 3000),
n_samples = 100,
n_factors = 2,
signal.samples = NULL,
signal.features.one = NULL,
signal.features.two = NULL,
snr = 2.5,
num.factor = 'multiple',
advanced_dist = 'mixed'
)
plot_weights(
sim_object = output_obj,
factor_num = 1,
data = 'omic.one',
type = 'scatter',
show.legend = FALSE
)
plot_weights(
sim_object = output_obj,
factor_num = "all",
data = 'omic.two',
type = 'histogram'
)
plot_weights(output_obj, factor_num = "all", data = "omic.one", type = "scatter")
plot_weights(
sim_object = output_obj,
factor_num = 2,
data = 'omic.two',
type = 'histogram'
)
remove(OmixCraftHD())
devtools::document()
rm(list = c("OmixCraftHD", "plot_weights"))
devtools::document()
devtools::check()
output_obj <- OmixCraftHD(
vector_features = c(4000, 3000),
n_samples = 100,
n_factors = 2,
snr = 2.5,
num.factor = "multiple",
advanced_dist = "mixed"
)
# Extract a valid factor number dynamically
available_factors <- as.numeric(gsub("[^0-9]", "", names(output_obj$list_betas)))
expect_true(length(available_factors) > 0)
available_factors
View(output_obj)
devtools::document()
devtools::check()
devtools::build()
devtools::document()
devtools::check()
devtools::build()
